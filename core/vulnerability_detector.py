"""
Vulnerability Detection Engine
"""

import re
import asyncio
from urllib.parse import urljoin, urlparse, parse_qs, quote
from typing import Dict, List, Any, Optional
import json
import hashlib

from .http_client import HTTPClient
from .config import config

class VulnerabilityDetector:
    """Main vulnerability detection engine"""
    
    def __init__(self, ai_engine=None):
        self.ai_engine = ai_engine
        self.http_client = HTTPClient()
        self.payloads = self._load_payloads()
        
    def _load_payloads(self) -> Dict[str, List[str]]:
        """Load vulnerability testing payloads"""
        return {
            'xss': [
                '<script>alert("XSS")</script>',
                '<img src=x onerror=alert("XSS")>',
                'javascript:alert("XSS")',
                '<svg onload=alert("XSS")>',
                '"><script>alert("XSS")</script>',
                "';alert('XSS');//",
                '<iframe src="javascript:alert(`XSS`)">',
                '<object data="javascript:alert(`XSS`)">'
            ],
            'sqli': [
                "' OR '1'='1",
                "' UNION SELECT null,version(),null--",
                "'; DROP TABLE users--",
                "' OR SLEEP(5)--",
                "' AND (SELECT COUNT(*) FROM information_schema.tables)>0--",
                "' UNION SELECT 1,2,3,4,5--",
                "' OR 1=1#",
                "') OR ('1'='1"
            ],
            'ssrf': [
                'http://localhost:80',
                'http://127.0.0.1:22',
                'http://169.254.169.254/latest/meta-data/',
                'file:///etc/passwd',
                'gopher://127.0.0.1:25/_HELO',
                'dict://127.0.0.1:11211/stats'
            ],
            'rce': [
                '; whoami',
                '| id',
                '`pwd`',
                '$(cat /etc/passwd)',
                '; cat /etc/passwd',
                '& echo "RCE"'
            ],
            'lfi': [
                '../../../etc/passwd',
                '....//....//....//etc/passwd',
                '/etc/passwd%00',
                'php://filter/convert.base64-encode/resource=index.php'
            ],
            'redirect': [
                'http://evil.com',
                '//evil.com',
                '@evil.com',
                'javascript:alert("Redirect")',
                'data:text/html,<script>alert("Redirect")</script>'
            ]
        }
    
    async def test_xss(self, targets: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Test for XSS vulnerabilities"""
        vulnerabilities = []
        urls = targets.get('urls', [])
        parameters = targets.get('parameters', [])
        forms = targets.get('forms', [])
        
        # Get optimized payloads from AI if available
        if self.ai_engine:
            payloads = await self.ai_engine.optimize_payloads('xss', targets)
        else:
            payloads = self.payloads['xss']
        
        # Test URL parameters
        for url in urls[:10]:  # Limit for demo
            for param in parameters:
                for payload in payloads[:3]:  # Limit payloads for demo
                    vuln = await self._test_xss_payload(url, param, payload)
                    if vuln:
                        vulnerabilities.append(vuln)
                        break  # Found XSS, move to next parameter
        
        # Test forms
        for form in forms[:5]:  # Limit for demo
            for payload in payloads[:3]:
                vuln = await self._test_xss_form(form, payload)
                if vuln:
                    vulnerabilities.append(vuln)
                    break
        
        return vulnerabilities
    
    async def _test_xss_payload(self, url: str, parameter: str, payload: str) -> Optional[Dict[str, Any]]:
        """Test a single XSS payload"""
        try:
            # Construct test URL
            separator = '&' if '?' in url else '?'
            test_url = f"{url}{separator}{parameter}={quote(payload)}"
            
            # Make request
            response = await self.http_client.get(test_url)
            
            # Check if payload is reflected
            if response['status_code'] == 200 and payload in response['text']:
                # Additional validation
                if self._validate_xss(response['text'], payload):
                    return {
                        'type': 'XSS',
                        'severity': self._get_xss_severity(payload, response['text']),
                        'url': test_url,
                        'parameter': parameter,
                        'payload': payload,
                        'response': response['text'][:1000],  # Truncate response
                        'description': f'XSS vulnerability found in parameter "{parameter}"',
                        'evidence': payload
                    }
        except Exception as e:
            pass  # Continue testing
        
        return None
    
    async def _test_xss_form(self, form: Dict[str, Any], payload: str) -> Optional[Dict[str, Any]]:
        """Test XSS in forms"""
        try:
            action_url = form.get('action', '')
            method = form.get('method', 'GET').upper()
            inputs = form.get('inputs', [])
            
            # Prepare form data
            form_data = {}
            for input_field in inputs:
                name = input_field.get('name', '')
                if name:
                    form_data[name] = payload
            
            # Submit form
            if method == 'POST':
                response = await self.http_client.post(action_url, data=form_data)
            else:
                response = await self.http_client.get(action_url, params=form_data)
            
            # Check for XSS
            if response['status_code'] == 200 and payload in response['text']:
                if self._validate_xss(response['text'], payload):
                    return {
                        'type': 'XSS',
                        'severity': self._get_xss_severity(payload, response['text']),
                        'url': action_url,
                        'method': method,
                        'payload': payload,
                        'response': response['text'][:1000],
                        'description': f'XSS vulnerability found in form submission',
                        'evidence': payload
                    }
        except Exception as e:
            pass
        
        return None
    
    def _validate_xss(self, response_text: str, payload: str) -> bool:
        """Validate XSS vulnerability"""
        # Check if payload is in a dangerous context
        dangerous_contexts = [
            r'<script[^>]*>' + re.escape(payload),
            r'<[^>]*on\w+\s*=\s*["\']?' + re.escape(payload),
            r'javascript:' + re.escape(payload),
            r'<iframe[^>]*src\s*=\s*["\']?' + re.escape(payload)
        ]
        
        for pattern in dangerous_contexts:
            if re.search(pattern, response_text, re.IGNORECASE):
                return True
        
        return False
    
    def _get_xss_severity(self, payload: str, response: str) -> str:
        """Determine XSS severity"""
        if '<script>' in payload or 'javascript:' in payload:
            return 'HIGH'
        elif 'onerror' in payload or 'onload' in payload:
            return 'MEDIUM'
        else:
            return 'LOW'
    
    async def test_sqli(self, targets: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Test for SQL injection vulnerabilities"""
        vulnerabilities = []
        urls = targets.get('urls', [])
        parameters = targets.get('parameters', [])
        
        # Get optimized payloads from AI
        if self.ai_engine:
            payloads = await self.ai_engine.optimize_payloads('sqli', targets)
        else:
            payloads = self.payloads['sqli']
        
        for url in urls[:10]:  # Limit for demo
            for param in parameters:
                for payload in payloads[:3]:  # Limit payloads
                    vuln = await self._test_sqli_payload(url, param, payload)
                    if vuln:
                        vulnerabilities.append(vuln)
                        break
        
        return vulnerabilities
    
    async def _test_sqli_payload(self, url: str, parameter: str, payload: str) -> Optional[Dict[str, Any]]:
        """Test a single SQL injection payload"""
        try:
            # Construct test URL
            separator = '&' if '?' in url else '?'
            test_url = f"{url}{separator}{parameter}={quote(payload)}"
            
            # Make request
            response = await self.http_client.get(test_url)
            
            # Check for SQL errors
            sql_errors = [
                'MySQL syntax error',
                'ORA-[0-9]{5}',
                'PostgreSQL.*ERROR',
                'Warning.*mysql_',
                'valid MySQL result',
                'SQLServer JDBC Driver',
                'SQLException',
                'sqlite3.OperationalError',
                'Microsoft OLE DB Provider for ODBC Drivers'
            ]
            
            for error_pattern in sql_errors:
                if re.search(error_pattern, response['text'], re.IGNORECASE):
                    return {
                        'type': 'SQLi',
                        'severity': 'HIGH',
                        'url': test_url,
                        'parameter': parameter,
                        'payload': payload,
                        'response': response['text'][:1000],
                        'description': f'SQL injection vulnerability found in parameter "{parameter}"',
                        'evidence': error_pattern
                    }
            
            # Time-based detection for blind SQLi
            if 'SLEEP(' in payload or 'WAITFOR' in payload:
                if response['response_time'] > 5:  # Assuming 5+ second delay indicates SQLi
                    return {
                        'type': 'Blind SQLi',
                        'severity': 'HIGH',
                        'url': test_url,
                        'parameter': parameter,
                        'payload': payload,
                        'response_time': response['response_time'],
                        'description': f'Time-based SQL injection in parameter "{parameter}"',
                        'evidence': f'Response time: {response["response_time"]:.2f}s'
                    }
        
        except Exception as e:
            pass
        
        return None
    
    async def test_ssrf(self, targets: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Test for SSRF vulnerabilities"""
        vulnerabilities = []
        urls = targets.get('urls', [])
        parameters = targets.get('parameters', [])
        
        # Get optimized payloads from AI
        if self.ai_engine:
            payloads = await self.ai_engine.optimize_payloads('ssrf', targets)
        else:
            payloads = self.payloads['ssrf']
        
        for url in urls[:5]:  # Limit for demo
            for param in parameters:
                if any(keyword in param.lower() for keyword in ['url', 'link', 'redirect', 'fetch', 'download']):
                    for payload in payloads[:3]:
                        vuln = await self._test_ssrf_payload(url, param, payload)
                        if vuln:
                            vulnerabilities.append(vuln)
                            break
        
        return vulnerabilities
    
    async def _test_ssrf_payload(self, url: str, parameter: str, payload: str) -> Optional[Dict[str, Any]]:
        """Test a single SSRF payload"""
        try:
            separator = '&' if '?' in url else '?'
            test_url = f"{url}{separator}{parameter}={quote(payload)}"
            
            response = await self.http_client.get(test_url)
            
            # Check for SSRF indicators
            ssrf_indicators = [
                'Connection refused',
                'Connection timed out',
                'No route to host',
                'Permission denied',
                'localhost',
                '127.0.0.1',
                'Internal Server Error',
                'HTTP/1.1 200 OK',  # If internal service responds
                'metadata',  # AWS metadata
                'file not found'  # File protocol
            ]
            
            for indicator in ssrf_indicators:
                if indicator.lower() in response['text'].lower():
                    return {
                        'type': 'SSRF',
                        'severity': 'HIGH',
                        'url': test_url,
                        'parameter': parameter,
                        'payload': payload,
                        'response': response['text'][:1000],
                        'description': f'SSRF vulnerability found in parameter "{parameter}"',
                        'evidence': indicator
                    }
        
        except Exception as e:
            pass
        
        return None
    
    async def test_rce(self, targets: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Test for Remote Code Execution vulnerabilities"""
        vulnerabilities = []
        urls = targets.get('urls', [])
        parameters = targets.get('parameters', [])
        
        # Get optimized payloads from AI
        if self.ai_engine:
            payloads = await self.ai_engine.optimize_payloads('rce', targets)
        else:
            payloads = self.payloads['rce']
        
        for url in urls[:5]:  # Limit for demo
            for param in parameters:
                if any(keyword in param.lower() for keyword in ['cmd', 'exec', 'command', 'system', 'eval']):
                    for payload in payloads[:3]:
                        vuln = await self._test_rce_payload(url, param, payload)
                        if vuln:
                            vulnerabilities.append(vuln)
                            break
        
        return vulnerabilities
    
    async def _test_rce_payload(self, url: str, parameter: str, payload: str) -> Optional[Dict[str, Any]]:
        """Test a single RCE payload"""
        try:
            separator = '&' if '?' in url else '?'
            test_url = f"{url}{separator}{parameter}={quote(payload)}"
            
            response = await self.http_client.get(test_url)
            
            # Check for command execution indicators
            rce_indicators = [
                'uid=',  # Unix user ID
                'gid=',  # Unix group ID
                'root:',  # /etc/passwd content
                'Windows IP Configuration',  # Windows ipconfig
                'Volume Serial Number',  # Windows dir command
                'total ',  # Unix ls command
                'Directory of',  # Windows dir
                'bash: ',  # Bash errors
                'sh: ',   # Shell errors
                'cmd: ',  # Command errors
                r'[a-zA-Z]:\\',  # Windows paths
                '/bin/',  # Unix paths
                '/usr/',
                '/etc/'
            ]
            
            for indicator in rce_indicators:
                if re.search(indicator, response['text'], re.IGNORECASE):
                    return {
                        'type': 'RCE',
                        'severity': 'CRITICAL',
                        'url': test_url,
                        'parameter': parameter,
                        'payload': payload,
                        'response': response['text'][:1000],
                        'description': f'Remote Code Execution vulnerability in parameter "{parameter}"',
                        'evidence': indicator
                    }
        
        except Exception as e:
            pass
        
        return None
    
    async def test_csrf(self, targets: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Test for CSRF vulnerabilities"""
        vulnerabilities = []
        forms = targets.get('forms', [])
        
        for form in forms:
            # Check if form is vulnerable to CSRF
            if self._is_csrf_vulnerable(form):
                vulnerabilities.append({
                    'type': 'CSRF',
                    'severity': 'MEDIUM',
                    'url': form.get('action', ''),
                    'method': form.get('method', 'GET'),
                    'description': 'Form lacks CSRF protection',
                    'evidence': 'No CSRF token found'
                })
        
        return vulnerabilities
    
    def _is_csrf_vulnerable(self, form: Dict[str, Any]) -> bool:
        """Check if form is vulnerable to CSRF"""
        inputs = form.get('inputs', [])
        csrf_tokens = ['csrf', 'token', '_token', 'authenticity_token', 'nonce']
        
        for input_field in inputs:
            name = input_field.get('name', '').lower()
            if any(token in name for token in csrf_tokens):
                return False
        
        return True
    
    async def test_idor(self, targets: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Test for IDOR vulnerabilities"""
        vulnerabilities = []
        urls = targets.get('urls', [])
        
        for url in urls:
            # Look for numeric IDs in URLs
            if re.search(r'[?&]id=\d+', url) or re.search(r'/\d+/', url):
                vuln = await self._test_idor_url(url)
                if vuln:
                    vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    async def _test_idor_url(self, url: str) -> Optional[Dict[str, Any]]:
        """Test a URL for IDOR vulnerability"""
        try:
            # Extract numeric ID and test with different values
            id_match = re.search(r'([?&]id=)(\d+)', url)
            if id_match:
                original_id = int(id_match.group(2))
                test_ids = [original_id + 1, original_id - 1, 1, 999]
                
                # Get original response
                original_response = await self.http_client.get(url)
                
                for test_id in test_ids:
                    test_url = url.replace(f'id={original_id}', f'id={test_id}')
                    test_response = await self.http_client.get(test_url)
                    
                    # Check if we get different but valid content
                    if (test_response['status_code'] == 200 and 
                        test_response['text'] != original_response['text'] and
                        len(test_response['text']) > 100):  # Avoid error pages
                        
                        return {
                            'type': 'IDOR',
                            'severity': 'HIGH',
                            'url': test_url,
                            'original_id': original_id,
                            'test_id': test_id,
                            'description': f'IDOR vulnerability allows access to other user data',
                            'evidence': f'ID {original_id} → {test_id} returned different content'
                        }
        
        except Exception as e:
            pass
        
        return None
    
    async def test_redirect(self, targets: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Test for Open Redirect vulnerabilities"""
        vulnerabilities = []
        urls = targets.get('urls', [])
        parameters = targets.get('parameters', [])
        
        redirect_params = ['redirect', 'url', 'return', 'continue', 'next', 'goto']
        
        for url in urls[:5]:  # Limit for demo
            for param in parameters:
                if any(rp in param.lower() for rp in redirect_params):
                    for payload in self.payloads['redirect'][:3]:
                        vuln = await self._test_redirect_payload(url, param, payload)
                        if vuln:
                            vulnerabilities.append(vuln)
                            break
        
        return vulnerabilities
    
    async def _test_redirect_payload(self, url: str, parameter: str, payload: str) -> Optional[Dict[str, Any]]:
        """Test a single redirect payload"""
        try:
            separator = '&' if '?' in url else '?'
            test_url = f"{url}{separator}{parameter}={quote(payload)}"
            
            response = await self.http_client.get(test_url, follow_redirects=False)
            
            # Check for redirect to external domain
            if response['status_code'] in [301, 302, 303, 307, 308]:
                location = response['headers'].get('location', '')
                if payload in location or 'evil.com' in location:
                    return {
                        'type': 'Open Redirect',
                        'severity': 'MEDIUM',
                        'url': test_url,
                        'parameter': parameter,
                        'payload': payload,
                        'redirect_location': location,
                        'description': f'Open redirect vulnerability in parameter "{parameter}"',
                        'evidence': f'Redirects to: {location}'
                    }
        
        except Exception as e:
            pass
        
        return None
